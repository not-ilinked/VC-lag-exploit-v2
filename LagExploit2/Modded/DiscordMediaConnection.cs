using Discord.Gateway;
using Discord.Media;
using Discord.WebSockets;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using WebSocketSharp;

namespace MuteExploit2
{
    internal class DiscordMediaConnection : DiscordWebSocket<DiscordMediaOpcode>
    {
        public delegate void WSMessageHandler(DiscordMediaConnection connection, DiscordWebSocketMessage<DiscordMediaOpcode> message);
        public event WSMessageHandler OnMessage;

        public delegate void ReadyHandler(DiscordMediaConnection connection);
        public event ReadyHandler OnReady;

        public delegate void KillHandler(DiscordMediaConnection connection, CloseEventArgs args);
        public event KillHandler OnDead;

        internal static readonly Dictionary<string, MediaCodec> SupportedCodecs = new Dictionary<string, MediaCodec>()
        {
            { "opus", new MediaCodec() { Name = "opus", Type = CodecType.Audio, PayloadType = 120, Priority = 1000 } },
            { "H264", new VideoMediaCodec() { Name = "H264", Type = CodecType.Video, PayloadType = 101, Priority = 1000, RtxPayloadType = 102 } }
        };

        public MediaConnectionState State { get; private set; }

        private readonly ulong _serverId;

        private readonly DiscordMediaServer _server;

        public DiscordSSRC SSRC { get; private set; }
        public byte[] SecretKey { get; set; }

        internal UdpClient UdpClient { get; private set; }
        public IPEndPoint ServerEndpoint { get; private set; }

        private readonly DiscordSocketClient _parentClient;

        public bool Authenticate { get; set; }

        public DiscordMediaConnection(DiscordSocketClient parentClient, ulong serverId, DiscordMediaServer server) : base("wss://" + server.Endpoint + "?v=4") 
        {
            SSRC = new DiscordSSRC();

            _parentClient = parentClient;

            _server = server;
            _serverId = serverId;

            OnMessageReceived += HandleMessage;
            OnClosed += HandleClose;
        }

        private void HandleClose(object sender, CloseEventArgs args)
        {
            State = MediaConnectionState.NotConnected;

            if (args.Code == 1006)
            {
                Thread.Sleep(200);
                Task.Run(() => Connect());
                return;
            }
            else if (args.Code >= 4000)
            {
                var discordCode = (DiscordMediaCloseCode)args.Code;

                if (discordCode == DiscordMediaCloseCode.SessionTimeout || discordCode == DiscordMediaCloseCode.ServerCrashed)
                {
                    Task.Run(() => Connect());
                    return;
                }
            }

            if (args.Code != 1004)
                OnDead?.Invoke(this, args);
        }

        private void HandleMessage(object sender, DiscordWebSocketMessage<DiscordMediaOpcode> message)
        {
            try
            {
                switch (message.Opcode)
                {
                    case DiscordMediaOpcode.Ready:
                        DiscordMediaReady ready = message.Data.ToObject<DiscordMediaReady>();

                        SSRC = new DiscordSSRC() { Audio = ready.SSRC };
                        ServerEndpoint = new IPEndPoint(IPAddress.Parse(ready.IP), ready.Port);

                        UdpClient = new UdpClient();
                        UdpClient.Connect(ServerEndpoint);

                        SelectProtocol(ServerEndpoint);
                        break;
                    case DiscordMediaOpcode.SessionDescription:
                        var description = message.Data.ToObject<DiscordSessionDescription>();

                        SecretKey = description.SecretKey;

                        State = MediaConnectionState.Ready;
                        OnReady?.Invoke(this);
                        break;
                    case DiscordMediaOpcode.Hello:
                        State = MediaConnectionState.Connected;

                        while (!Authenticate) { Thread.Sleep(1); }

                        Send(DiscordMediaOpcode.Identify, new DiscordMediaIdentify()
                        {
                            ServerId = _serverId,
                            UserId = _parentClient.User.Id,
                            SessionId = _parentClient.SessionId,
                            Token = _server.Token,
                            Video = true
                        });

                        StartHeartbeaterAsync(message.Data.Value<int>("heartbeat_interval"));
                        break;
                    default:
                        OnMessage?.Invoke(this, message);
                        break;
                }
            }
            catch (InvalidOperationException) { }
        }

        public new void Connect()
        {
            State = MediaConnectionState.Connecting;
            base.Connect();
        }


        public void SetSSRC(uint audioSsrc)
        {
            SSRC = new DiscordSSRC() { Audio = audioSsrc, Video = audioSsrc + 1, Rtx = audioSsrc + 2 };
            Send(DiscordMediaOpcode.SSRCUpdate, SSRC);
        }


        private async void StartHeartbeaterAsync(int interval)
        {
            try
            {
                while (true)
                {
                    Send(DiscordMediaOpcode.Heartbeat, DateTimeOffset.UtcNow.ToUnixTimeMilliseconds());
                    await Task.Delay(interval);
                }
            }
            catch (InvalidOperationException) { }
        }


        private void SelectProtocol(IPEndPoint localEndpoint)
        {
            Send(DiscordMediaOpcode.SelectProtocol, new MediaProtocolSelection()
            {
                Protocol = "udp",
                ProtocolData = new MediaProtocolData()
                {
                    Host = localEndpoint.Address.ToString(),
                    Port = localEndpoint.Port,
                    EncryptionMode = "xsalsa20_poly1305"
                },
                RtcConnectionId = Guid.NewGuid().ToString(),
                Codecs = SupportedCodecs.Values.ToList()
            });
        }
    }
}
